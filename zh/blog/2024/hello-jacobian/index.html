<!DOCTYPE html> <html> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <script language="Javascript">document.oncontextmenu=new Function("event.returnValue=false"),document.onselectstart=new Function("event.returnValue=false");</script> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title> 老师，我太想写SLAM了-李群/李代数篇 | Qi. Wu </title> <meta name="author" content="Qi. Wu"> <meta name="description" content="本篇论文主要以“A micro Lie theory for state estimation in robotics”这篇论文为基础，简单介绍下李群李代数在SLAM中的应用。与以外介绍不同的是，本篇更多的是在介绍在于求导Jacobian方面，希望能更快地帮助同学们克服SLAM状态估计过程中的求导难题，进而能快更好地写出自己的算法，加速研究进度。"> <meta name="keywords" content="CQUPT, BUPT, SJTU, SLAM Reasearcher"> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link defer rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons&amp;display=swap"> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?591dab5a4e56573bf4ef7fd332894c99" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="data:image/svg+xml,&lt;svg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20100%20100%22&gt;&lt;text%20y=%22.9em%22%20font-size=%2290%22&gt;%E2%9A%9B%EF%B8%8F&lt;/text&gt;&lt;/svg&gt;"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://gatsby23.github.io/zh/blog/2024/hello-jacobian/"> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-native.css?5847e5ed4a4568527aa6cfab446049ca" media="none" id="highlight_theme_dark"> <script src="/assets/js/theme.js?0afe9f0ae161375728f7bcc5eb5b4ab4"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.1.0/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?85ddb88934d28b74e78031fd54cf8308"></script> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js"></script> <script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script src="/assets/js/distillpub/template.v2.js"></script> <script src="/assets/js/distillpub/transforms.v2.js"></script> <script src="/assets/js/distillpub/overrides.js"></script> <d-front-matter> <script async type="text/json">
      {
            "title": "老师，我太想写SLAM了-李群/李代数篇",
            "description": "本篇论文主要以“A micro Lie theory for state estimation in robotics”这篇论文为基础，简单介绍下李群李代数在SLAM中的应用。与以外介绍不同的是，本篇更多的是在介绍在于求导Jacobian方面，希望能更快地帮助同学们克服SLAM状态估计过程中的求导难题，进而能快更好地写出自己的算法，加速研究进度。",
            "published": "March 24, 2024",
            "authors": [
              
              {
                "author": "作者：吴奇/徐翔宇",
                "authorURL": "",
                "affiliations": [
                  {
                    "name": "SJTU",
                    "url": ""
                  }
                ]
              },
              
              {
                "author": "审核：郁文贤/裴凌/邹丹平",
                "authorURL": "",
                "affiliations": [
                  {
                    "name": "SJTU",
                    "url": ""
                  }
                ]
              }
              
            ],
            "katex": {
              "delimiters": [
                {
                  "left": "$",
                  "right": "$",
                  "display": false
                },
                {
                  "left": "$$",
                  "right": "$$",
                  "display": true
                }
              ]
            }
          }
    </script> </d-front-matter> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top" role="navigation"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/zh/"> <span class="font-weight-bold">Qi. </span> Wu </a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/zh/">about </a> </li> <li class="nav-item "> <a class="nav-link" href="/zh/blog/">blog </a> </li> <li class="nav-item "> <a class="nav-link" href="/zh/publications/">publications </a> </li> <li class="nav-item "> <a class="nav-link" href="/zh/projects/">projects </a> </li> <li class="nav-item "> <a class="nav-link" href="/zh/repositories/">repositories </a> </li> <li class="nav-item "> <a class="nav-link" href="/zh/cv/">cv </a> </li> <li class="nav-item "> <a class="nav-link" href="/zh/people/">people </a> </li> <li class="nav-item active"> <a class="nav-link" href="/blog/2024/hello-jacobian/">EN</a> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="fa-solid fa-moon"></i> <i class="fa-solid fa-sun"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="post distill"> <d-title> <h1>老师，我太想写SLAM了-李群/李代数篇</h1> <p>本篇论文主要以“A micro Lie theory for state estimation in robotics”这篇论文为基础，简单介绍下李群李代数在SLAM中的应用。与以外介绍不同的是，本篇更多的是在介绍在于求导Jacobian方面，希望能更快地帮助同学们克服SLAM状态估计过程中的求导难题，进而能快更好地写出自己的算法，加速研究进度。</p> </d-title> <d-byline></d-byline> <d-article> <h1 id="前言">前言</h1> <p>SLAM的一个核心问题是估计由位置（3DOF）和姿态(3DOF)组成的6DOF刚体运动。对于研究者来说，不同论文/系统中对方向的定义差异和旋转矩阵本身不可求导的特性都会给学习过程带来较大的困扰。对于前者来说，通常在论文第三章的开始部分，都会给出定义是World-&gt;Body还是Body-&gt;World，然后对于后者来说，研究者通常会用欧拉角、四元数或李群等方式来对位姿进行参数化表示。</p> <p>欧拉角表示除了本身具有的万向锁问题外，也会因为旋转顺序的不同导致求导过程中特别复杂，这个在<a href="https://github.com/laboshinl/loam_velodyne/tree/master" rel="external nofollow noopener" target="_blank">loam_velodyne</a>的实现中尤为明显。四元数的表示存在JPL和Hamilton两种表示情况，其中经典算法<a href="https://docs.openvins.com/" rel="external nofollow noopener" target="_blank">OpenVINS</a>采用的是基于JPL的旋转表示，<a href="https://github.com/HKUST-Aerial-Robotics/VINS-Mono" rel="external nofollow noopener" target="_blank">VINS-Mono</a>采用的是Hamilton的数学表示。表明上看，两种表示方法不同仅仅是方向的不同（JPL通常表示的是World-&gt;Body，而Hamilton表示的是Body-&gt;World，似乎更适用于机器人学），但数学上两种表示方式也各有各的缺陷及其对应的优化解决方案，具体可看知乎上<a href="https://zhuanlan.zhihu.com/p/269257787" rel="external nofollow noopener" target="_blank">wuRDmemory的解析</a>、<a href="https://zhuanlan.zhihu.com/p/96465592" rel="external nofollow noopener" target="_blank">泡泡邱笑晨的四元数误差传播</a>和Joan Sola的<a href="https://arxiv.org/pdf/1711.02508.pdf" rel="external nofollow noopener" target="_blank">Quaternion kinematics for the error-state Kalman filter</a>这三篇文章，相信你读完后就有自己的理解和答案。</p> <p>鉴于前面两种表示方法现在已经有很多blog解析，所以我们就着重探讨基于李群/李代数的位姿表示。本篇Blog中，我们将以Joan Sola的<a href="https://arxiv.org/pdf/1812.01537.pdf" rel="external nofollow noopener" target="_blank">a micro lie theory for state estimation in robotics</a><d-cite key="sola2018micro"></d-cite>为基础主要探讨SO3和SE3的群。不同于以往blog中仅讨论其数学表示，本篇blog也将着重讨论如何通过差分求导的方式实现不同群上的jacobian求导，加速大家在算法开发。毕竟，老师，我太想做SLAM了。</p> <h1 id="第一章-机器人学中的李群李代数的基础定义">第一章 机器人学中的李群/李代数的基础定义.</h1> <p>为了保证行文逻辑通顺，我们在这里将简要回顾下李群/李代数的基础概念。如前文所述，我们将不再对于李群和李代数之间的关系进行深入探讨，而更多的讨论基于群下的机器人运算。从数学上来看，机器人是喜欢李群的原因是，群可以通过的映射关系找到对应的向量空间，从而保证位姿本身的特性。如基于旋转的群即是\(SO(3)\)，对应的是\(\mathfrak{so(3)}\)李代数。基于旋转加位姿的群是\(SE(3)\)，对应的李代数是\(\mathfrak{se(3)}\)。基于旋转加位姿加速度的群\(SE_{2}(3)\)，对应的李代数是\(\mathfrak{se_{2}(3)}\)。在我粗浅的理解\(SE_{2}(3)\)群最大的好处是可以解决滤波中的可观性问题，我们会在滤波的章节再进行深入理解，在本篇blog中将不做过多的讨论，更多精力将放在\(SO(3)\)和\(SE(3)的讨论上\)。那么首先，我们来回顾下什么是群。</p> <h2 id="11-群">1.1 群.</h2> <p>如<d-cite key="sola2018micro"></d-cite>书里所描述，群是由集合和运算共同组成。《SLAM十四讲》中提到过一个四字口诀：“封、结、幺、逆”，假设集合(（\(\mathcal{G}\)）和运算（\(\circ\)）)满足如下特性，则我们称其(\(\mathcal{G}, \circ\))为一个群： $$ \begin{equation} \begin{aligned} &amp;\text{封：} \mathcal{X} \circ \mathcal{Y} \in \mathcal{G} <br> \end{aligned} \end{equation}</p> <figcaption>集合中的元素经过运算后依然在原来的集合里，并不会超出集合范围，能保证描述的原始数学属性。</figcaption> <p>\begin{equation} \begin{aligned} &amp;\text{结：}（\mathcal{X} \circ \mathcal{Y}）\circ \mathcal{Z} = \mathcal{X} \circ (\mathcal{Y} \circ \mathcal{Z}) <br> \end{aligned} \end{equation}</p> <p>\begin{equation} \begin{aligned} &amp;\text{幺：} \mathcal{E} \circ \mathcal{X} = \mathcal{X} \circ \mathcal{E} = \mathcal{X} \end{aligned} \end{equation}</p> <figcaption>单位元素是群中的一个特殊元素，在单位元素上的切平面即是这个群对应的李代数。</figcaption> <p>\begin{equation} \begin{aligned} &amp;\text{逆：}\mathcal{X} \circ \mathcal{X}^{-1} = \mathcal{X}^{-1} \circ \mathcal{X} = \mathcal{E} \end{aligned} \end{equation}</p> <figcaption>由于一个群中必须有一个单位元素，所以每个元素在这个群中肯定都得有一个对应的逆元素。</figcaption> <p>$$</p> <p>我们把满足上述的群画出来，则其拓扑表示应该如下所示：</p> <div class="l-body"> <img class="img-fluid rounded z-depth-1" src="/zh/../assets/img/hello-jacobian/lie_typo.jpg"> <figcaption style="text-align: center; margin-top: 10px; margin-bottom: 10px;"> 李群的拓扑表示，对应的数学符号请参考论文<d-cite key="sola2018micro"></d-cite> </figcaption> </div> <p>观察拓扑表示，我们就会发现，群上每一个点都是一样的。这些约束让群成了一个光滑的表面。我粗浅的微积分知识告诉我，在这种情况下，原本在欧式空间中不可导的旋转矩阵通过转换变成了局部可微了。由于<a href="(https://www.zhihu.com/question/357305394/answer/944401383)">光滑是函数可微的重要条件</a>，所以李群也常常被人们叫光滑流形（以上为个人记忆方法，并不一定符合数学严谨性，如果有问题欢迎讨论和拍砖）。</p> <p>在机器人中，无论2D还是3D应用。李群具有将集合元素变化，并进行旋转、平移、缩放以及他们任意组合的操作能力。则 $$ \begin{equation} \begin{aligned} SO(n)&amp;: \hspace{1em} \text{旋转矩阵} \hspace{1em} \mathbf{R} \cdot \mathbf{x} \triangleq \mathbf{R}\mathbf{x} \end{aligned} \end{equation}</p> <p>\begin{equation} \begin{aligned} SE(n)&amp;: \hspace{1em} \text{欧式矩阵} \hspace{1em} \mathbf{H} \cdot \mathbf{x} \triangleq \mathbf{R}\mathbf{x} + \mathbf{t} \end{aligned} \end{equation} $$</p> <p>这里的$n$表示的是维度。当$n=2$时，表示的是2D空间下的机器人运动，当$n=3$时，表示的是3D空间下的机器人运动。</p> <h2 id="12-切向量空间和李代数">1.2 切向量空间和李代数.</h2> <p>在单位元素附近的切空间$\mathrm{T}_{\mathcal{E}}\mathcal{M}$称为群$\mathcal{M}$的李代数$\mathcal{m}$，则： \(\begin{equation} \begin{aligned} \text{李代数} \hspace{1em} \mathcal{m} \triangleq \mathrm{T}_{\mathcal{E}}\mathcal{M} \end{aligned} \end{equation}\)</p> <p>这里的$\mathcal{m}$是一个向量空间，它的元素可以被视为$\mathbb{R}$空间下的向量，$\mathcal{m}$的维度就是李群$\mathcal{M}$的自由度。而指数映射$exp$和对数映射$log$则是李群和李代数的相互转换方式，<strong>注意在这里的两个符号都是小写，表示的是李代数（切向量空间）上的元素转化，并不是所有维度下的向量都可以进行转换</strong>，我们在这里通常用$\land$帽子符号来说明李代数$\mathcal{m}$。为了方便我们直接在欧式空间$\mathbb{R}^3$上进行操作，所以我们还需要做欧式空间$\mathbb{R}^3$和李代数$\mathcal{m}$上的映射。依据群的特性(参考《SLAM十四讲》第三章<d-cite key="高翔2017视觉"></d-cite>，公式3.4)，我们发现每个李代数即是欧式空间下向量的反对称矩阵，因此我们可以定义转换关系如下所示即：</p> \[\begin{equation} \begin{aligned} \land &amp;: \hspace{1em} \text{欧式空间}\mathbb{R}^{m} \rightarrow \mathcal{m} \hspace{1em} \tau \rightarrow \tau^{\land} = \sum_{i=1}^{m} \tau_{i} \mathbf{E}_{i} \\ \end{aligned} \end{equation}\] \[\begin{equation} \begin{aligned} \vee &amp;: \hspace{1em} \mathcal{m} \rightarrow \text{欧式空间}\mathbb{R}^{m} \hspace{1em} {（\tau^{\land}}）^{\vee} \rightarrow \tau= \sum_{i=1}^{m} \tau_{i} \mathbf{e}_{i} \\ \end{aligned} \end{equation}\] <p>这里$\mathbf{e_{i}}$表示的是李代数$\mathcal{m}$下的基底，而$\mathbf{E_{i}}$是欧式空间下$\mathbb{R}^{m}$下的基底。所以我们可以定义欧式空间到李群的映射（$\mathrm{Exp}$和$\mathrm{Log}$），即：</p> \[\begin{equation} \begin{aligned} \mathrm{Exp} &amp;: \hspace{1em} \text{欧式空间}\mathbb{R}^{m} \rightarrow \mathcal{M} \hspace{1em} \mathcal{X} = Exp(\tau) \triangleq exp(\tau^{\land}) \\ \end{aligned} \end{equation}\] \[\begin{equation} \begin{aligned} \mathrm{Log} &amp;: \hspace{1em} \mathcal{M} \rightarrow \text{欧式空间}\mathbb{R}^{m} \hspace{1em} \tau = Log(\mathcal{X}) \triangleq log(\mathcal{X})^{\vee} \\ \end{aligned} \end{equation}\] <p>我们对公式（10）进行泰勒展开即可得到： \(\begin{equation} \begin{aligned} \mathcal{X} = exp(\tau^{\land}) = \mathcal{E} + \tau^{\land} + \frac{1}{2}\tau^{\land^{2}} + \frac{1}{3}\tau^{\land^{3}} + ... \\ \end{aligned} \end{equation}\) 在这里大家请记住公式（12），尤其当$\tau$是小量时，公式（12）可以简化为<strong>$exp(\tau^{\land}) \simeq \mathcal{E} + \tau^{\land}$</strong>是后面公式计算jacobian的重要工具之一。由于指数的性质，我们可以进一步得出李代数满足如下性质： $$ \begin{equation} \begin{aligned} \mathrm{exp((t+s)\tau^{\land})} = \mathrm{exp(t\tau^{\land})} \mathrm{exp(s\tau^{\land})} <br> \end{aligned} \end{equation}</p> <p>\begin{equation} \begin{aligned} \mathrm{exp(t\tau^{\land})} = \mathrm{exp(\tau^{\land})^{t}} <br> \end{aligned} \end{equation}</p> <p>\begin{equation} \begin{aligned} \mathrm{exp(-\tau^{\land})} = \mathrm{exp(\tau^{\land})^{-1}} <br> \end{aligned} \end{equation}</p> <p>\begin{equation} \begin{aligned} \mathrm{exp(\mathcal{X}\tau^{\land}\mathcal{X}^{-1})} = \mathcal{X}\mathrm{exp(\tau^{\land})}\mathcal{X}^{-1} <br> \end{aligned} \end{equation} $$ 对此至此，我们对欧式空间、李代数和李群的基础定义介绍完毕。</p> <h1 id="机器人学中的李群李代数运算">机器人学中的李群/李代数运算</h1> <h2 id="21-运算的方向">2.1 运算的方向</h2> <p>加法($ \oplus $)/减法($ \ominus $)是流形上用于表示运动递增/递减的常见运算之一。如图所示，每次的运算都是在当前点的切平面上。由于流形本身光滑的原因，由于当前点的切平面方向也在变化，造成的影响是每次递增或递减的方向也不同。所以对于群上来说左加还是右加，左减还是右减得到结果也都不同。</p> <div class="l-body"> <img class="img-fluid rounded z-depth-1" src="/zh/../assets/img/hello-jacobian/lie_Cal.jpg"> <figcaption style="text-align: center; margin-top: 10px; margin-bottom: 10px;"> 李群的运算，需要主要到的是从$\mathcal{E}$到$\mathcal{Y}$和$\mathcal{Y}$到\mathcal{E}并不是同一条路径。<d-cite key="sola2018micro"></d-cite> </figcaption> </div> <p>我们定义右加如下： $$ \begin{equation} \begin{aligned} \mathcal{Y} = \mathcal{X} \oplus {^{\mathcal{X}}\tau} \triangleq \mathcal{X} \circ \mathrm{Exp}({^{\mathcal{X}}\tau}) \in \mathcal{M} <br> \end{aligned} \end{equation}</p> <p>\begin{equation} \begin{aligned} {^{\mathcal{X}}\tau} = \mathcal{Y} \ominus \mathcal{X} \triangleq Log(\mathcal{X}^{-1} \circ \mathcal{Y}) \in T_{\mathcal{X}}\mathcal{M} <br> \end{aligned} \end{equation} $$</p> <p>需要注意的是这里${^{\mathcal{X}}\tau}$表示的应该是在$\mathcal{X}$点局部切平面上的无限小量。这里我们用左上标表示该小量所在的局部坐标系。从作者的粗浅理解来看，右运算在机器人学中相当于局部坐标系下的变化，对应的是四元数中的hamilton表示方式（<strong>这里粗浅的理解不一定正确，如果有错误，请及时拍砖并告诉我</strong>）。同理对应的左加/左减运算定义如下，这里小量是在全局坐标系下（我的理解对应的是四元数中的JPL表示方式）： $$ \begin{equation} \begin{aligned} \mathcal{Y} = {^{\mathcal{E}}\tau} \oplus \mathcal{X} \triangleq \mathrm{Exp}({^{\mathcal{E}}\tau}) \circ \mathcal{X} \in \mathcal{M} <br> \end{aligned} \end{equation}</p> <p>\begin{equation} \begin{aligned} {^{\mathcal{E}}\tau} = \mathcal{Y} \ominus \mathcal{X} \triangleq Log(\mathcal{Y} \circ \mathcal{X}^{-1} ) \in T_{\mathcal{E}}\mathcal{M} <br> \end{aligned} \end{equation} $$</p> <h2 id="22-伴随伴随矩阵">2.2 伴随/伴随矩阵</h2> <p>由2.1，我们可知，李群本身并不满足交换律，所以机器人本身运动在局部坐标系下的递增幅度（右加）和全局坐标系下的递增幅度（左加）并不相同。由公式（17）和公式（19），我们可得：$ {^{\mathcal{E}}\tau} \oplus \mathcal{X} = \mathcal{X} \oplus {^{\mathcal{X}}\tau}$，并做如下递推： \(\begin{equation} \begin{aligned} \mathrm{Exp}({^{\mathcal{E}}\tau}) \mathcal{X} = \mathcal{X} \mathrm{Exp}({^{\mathcal{X}}\tau}) \\ \end{aligned} \end{equation}\)</p> \[\begin{equation} \begin{aligned} \mathrm{exp}({^{\mathcal{E}}\tau^{\land}}) = \mathcal{X} \mathrm{exp}({^{\mathcal{X}}\tau^{\land}}) \mathcal{X}^{-1} = \mathrm{exp}(\mathcal{X}{^{\mathcal{X}}\tau^{\land}}\mathcal{X}^{-1}) \\ \end{aligned} \end{equation}\] \[\begin{equation} \begin{aligned} {^{\mathcal{E}}\tau^{\land}} = \mathcal{X} {^{\mathcal{X}}\tau^{\land}} \mathcal{X}^{-1} \\ \end{aligned} \end{equation}\] <p>如上所述，由公式（16）（21）（22），我们可以得到公式（23）。即局部坐标系下的增量与全局坐标系下的增量关系。因此我们可以定义状态$\mathcal{X}$的伴随如下： \(\begin{equation} \begin{aligned} \mathrm{Ad}_{\mathcal{X}}: \mathcal{m} \rightarrow \mathcal{m}\text{;} \hspace{1em} \tau^{\land} \rightarrow \mathrm{Ad}_{\mathcal{X}}(\tau^{\land}) \mathcal{X} {^{\mathcal{X}}\tau^{\land}} \mathcal{X}^{-1} \\ \end{aligned} \end{equation}\) 需要注意的是这里的伴随符号$\mathrm{Ad}_{\mathcal{X}}$并没有加粗，表示的是在李代数上的运算，依据定义我们可知在李代数$\mathcal{m}$上的伴随具有如下性质： \(\begin{equation} \begin{aligned} \text{齐次性：} \mathrm{Ad}_{\mathcal{X}}(a\tau^{\land} + b\sigma^{\land})= a\mathrm{Ad}_{\mathcal{X}}(\tau^{\land}) + b \mathrm{Ad}_{\mathcal{X}}(\sigma^{\land}) \\ \end{aligned} \end{equation}\)</p> \[\begin{equation} \begin{aligned} \text{同态：} \mathrm{Ad}_{\mathcal{X}}(\mathrm{Ad}_{\mathcal{Y}}(\tau^{\land}))= \mathrm{Ad}_{\mathcal{XY}}(\tau^{\land})\\ \end{aligned} \end{equation}\] <p>对应的，在欧式空间$\mathbb{R}$下的伴随矩阵则定义如下： \(\begin{equation} \begin{aligned} \mathbf{Ad}_{\mathcal{X}}: \mathbb{R}^m \rightarrow \mathbb{R}^m\text{;} \hspace{1em} {^{\mathcal{X}}\tau^{\land}} \rightarrow {^{\mathcal{E}}\tau^{\land}} = \mathbf{Ad}_{\mathcal{X}}{^{\mathcal{X}}\tau^{\land}} \\ \end{aligned} \end{equation}\)</p> <p>注意到这里的$\mathbf{Ad}_{\mathcal{X}}$是加粗的，表示在欧式空间$\mathbb{R}$上的操作，依据定义，我们还能得到如下性质： \(\begin{equation} \begin{aligned} \mathcal{X} \oplus \tau = (\mathbf{Ad}_{\mathcal{X}}\tau) \oplus \mathcal{X} \\ \end{aligned} \end{equation}\)</p> \[\begin{equation} \begin{aligned} \mathbf{Ad}_{\mathcal{X}^{-1}} = \mathbf{Ad}_{\mathcal{X}}^{-1} \\ \end{aligned} \end{equation}\] <p>\(\begin{equation} \begin{aligned} \mathbf{Ad}_{\mathcal{X}\mathcal{Y}} = \mathbf{Ad}_{\mathcal{X}} \mathbf{Ad}_{\mathcal{Y}} \\ \end{aligned} \end{equation}\) 到此，我们有关李群上的运算基本介绍完成，下面开始介绍开发者最头疼的部分李群/李代数上的导数。</p> <h2 id="23-李群上的导数">2.3 李群上的导数</h2> <p>回顾下导数的定义，当我们对一个函数求导的时候，求导方式定义如下： \(\begin{equation} \mathbf{J} = \frac{\partial f(\mathbf{x})}{\partial \mathbf{x}} \triangleq \lim_{\mathbf{h} \rightarrow 0} \frac{f(\mathbf{x}+\mathbf{h}) - f(\mathbf{x})}{\mathbf{x}} \in \mathbb{R} \end{equation}\) 由于我们前面提过群本身是流形且光滑，所以基于上式，我们基本上可以推导出机器人学中常用的jacobian，定义如下： \(\begin{equation} \frac{^{\mathcal{X}}Df(\mathcal{X})}{D\mathcal{X}} = \lim_{\tau \rightarrow 0} \frac{f(\mathcal{X} \oplus \tau) \ominus f(\mathcal{X})}{\tau} \in \mathbb{R} \end{equation}\)</p> <p>如前文所述，我们将在下面着重对$SO(3)$旋转群和$SE(3)$运动群进行推导。</p> <h3 id="231-so3群上导数">2.3.1 SO(3)群上导数</h3> <p>$SO(3)+\mathbf{t}$是激光SLAM中最常用的位姿表现形式，其中点的变化是一系列推导工作的基础。我们在这里就针对这个问题来进行jacobian推导。这里位姿$\mathbf{T} = [\mathbf{R}, \mathbf{t}]$，则点的变化为$f(\mathbf{T}) = \mathbf{R} \mathbf{P} + \mathbf{t}$，对此我们可以通过右扰动求导如下： \(\begin{equation} \begin{aligned} \frac{^{\mathbf{R}}D(\mathbf{R}\mathbf{P}+\mathbf{t})}{D\mathbf{R}} &amp;= \lim_{\theta \rightarrow 0} \frac{[(\mathbf{R} \oplus \mathbf{\theta})\mathbf{P} + \mathbf{t}] \ominus f(\mathbf{T})}{\mathbf{\theta}} \\ &amp;= \lim_{\theta \rightarrow 0} \frac{[(\mathbf{R} \mathbf{Exp}(\theta))\mathbf{P} + \bcancel{\mathbf{t}}] - [\mathbf{R}\mathbf{P} + \bcancel{\mathbf{t}}]}{\theta} \\ &amp;\simeq \frac{[\mathbf{R}(\bcancel{\mathbf{I}} + [\mathbf{\theta}]_{\times})\mathbf{P}] - \bcancel{\mathbf{R}\mathbf{P}}}{\theta} = \frac{\mathbf{R}[\mathbf{\theta}]_{\times}\mathbf{P}}{\mathbf{\theta}} \\ &amp;= \lim_{\theta \rightarrow 0} \frac{-\mathbf{R}[\mathbf{P}]_{\times}\mathbf{\theta}}{\mathbf{\theta}} \\ &amp;= -\mathbf{R}[\mathbf{P}]_{\times} \in \mathbb{R}^{3 \times 3} \end{aligned} \end{equation}\) 需要注意，在这里推导的时候$\mathbf{\theta}$应该是接近于0的无限小量，这样才能满足之前提到的公式（12）要求，对整体做近似。对此，我们对$SO(3)$的群进行右扰动求导完成。当然对SO(3)也可以进行左扰动求导（因为当日写公式时间太久，所以暂时不做推导，后续补上）。</p> <h3 id="232-se3群上导数">2.3.2 SE(3)群上导数</h3> <p>类似于上面的$SO(3)$群，我们也可以通过右扰动对$SE(3)$进行Jacobian求解。考虑到《SLAM十四讲》<d-cite key="高翔2017视觉"></d-cite>的4.3.5小节已通过左扰动对该部分进行了详解。所以在本篇文章中，我们直接将通过左扰动求导得到的Jacobian直接写上，右扰动的推导后续再放入来增强文章的完整性：</p> \[\begin{equation} \mathbf{J} = \begin{bmatrix} \mathbf{I} &amp; -(\mathbf{R}\mathbf{P} + \mathbf{t})^{\land} \\ \mathbf{0}^{T} &amp; \mathbf{0}^{T} \end{bmatrix} \end{equation}\] <p>对此，关于$SO(3)$和$SE(3)$的Jacobian解析式求导已完成。如前言里说的一样，基于李群的解析式求导在目前的很多SLAM系统中都能看到：如$SO(3)$求导在港大的<a href="https://github.com/hku-mars/FAST_LIO" rel="external nofollow noopener" target="_blank">Fast-LIO</a><d-cite key="xu2021fast"></d-cite>和<a href="https://github.com/hku-mars/r3live" rel="external nofollow noopener" target="_blank">RLiVE系统</a><d-cite key="lin2022r"></d-cite>中常见。$SE(3)$则在<a href="https://github.com/wh200720041/floam/issues/17" rel="external nofollow noopener" target="_blank">F-LOAM</a><d-cite key="wang2021f"></d-cite>中有不错的效果体现。电影《后会无期》里有句话:“明白很多道理，却过不好这一生”。做SLAM的同学也是，看会了和真的求解正确可能还具有一定的距离，解析式求导正确到系统里的正确实现也因工程能力而产生更大距离。那么我们能不能有更好的方法直接在系统里正确实现呢？下面将清楚我们的主角：数值差分Jacobian。</p> <h1 id="数值差分jacobian及其代码实现">数值差分Jacobian及其代码实现</h1> <p>我在博一的时候，实验室<a href="https://drone.sjtu.edu.cn/dpzou/" rel="external nofollow noopener" target="_blank">邹丹平</a>老师就经常和我说：“别在纸上推啦，推又推不对，推对了又写错，有啥用，还不如直接差分求导”。</p> <div class="c-body"> <img class="img-fluid rounded z-depth-1" src="/zh/../assets/img/hello-jacobian/dp.jpg"> <figcaption style="text-align: center; margin-top: 10px; margin-bottom: 10px;"> 邹老师在我们心中的形象，SLAM界绝对的武林高手。<d-cite key="sola2018micro"></d-cite> </figcaption> </div> <p>我不知道怎么和他开口说，不是我不想用，而是我不会。有次好不容易鼓起勇气问他，他：“哇靠，这都不会，<a href="https://drone.sjtu.edu.cn/static/assets/pdfs/course/lecture07-08-nonlinear_least_square_ransac.pdf" rel="external nofollow noopener" target="_blank">看我PPT第28页</a>，写的不能再清楚了”。</p> <div class="l-body"> <img class="img-fluid rounded z-depth-1" src="/zh/../assets/img/hello-jacobian/num-diff.jpg"> <figcaption style="text-align: center; margin-top: 10px; margin-bottom: 10px;"> 邹老师口中清楚的PPT，每一个单词都认识，但是合在一起真是没看懂。<d-cite key="sola2018micro"></d-cite> </figcaption> </div> <p>在那个时候我明白了，高手眼里的世界和我们菜狗眼里的世界是不一样的。现在我博五，回过头来看，明白是自己当初对公式（31）理解不够深入的，下面我们来对公式代码化：用<a href="https://github.com/strasdat/Sophus" rel="external nofollow noopener" target="_blank">Sophus库</a>来表示当前状态。矩阵操作依赖<a href="https://gitlab.com/libeigen/eigen" rel="external nofollow noopener" target="_blank">Eigen</a>库来实现，主要对上面的$SO(3)$群的例子进行数值Jacobian求导。 回顾PPT里，这里最主要需要实现的就是优化函数(cost function)：即$\mathbf{R}\mathbf{P}+\mathbf{t}$。剩下的就是定义小量，计算优化函数变化，得到的就是对应的数值差分jacobian，C++伪代码定义如下（这里我们主要考虑的就是旋转，平移部分做相同操作即可）：</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// 定义小量:
double delta = 1e-7;
// Map the delta into the rotation.
for(i = 0; i &lt; 3; ++i) {
  Eigen::Vector3d delta_vector = Eigen::Vector3d::Zero();
  delta_vector(i) = delta;
  // current_state是我们定义机器人状态量，包含机器人当前姿态和位置。
  Sophus::SO3d delta_rotation = current_state.rotation * Sophus::SO3d::exp(delta_vector);
  Eigen::Vector3d delta_map_point = delta_rotation * point + current_state.position;
  Eigen::Vector3d delta_error = ( delta_map_point  - current_map_point);
  Eigen::Vector3d num_diff_vector = delta_error / delta;
  LOG(INFO) &lt;&lt; num_diff_vector.transpose();
}
</code></pre></div></div> <p>通过代码不难看出，差分求jacobian实际上就是对每一个部分进行小扰动后看整体优化函数的变化幅度（也就是微分的定义）。从开发的角度来看，这种方式的确在SLAM工程初期能快速地求解出jacobian。虽然该方法实际运行效率相对较低，但是我们可以在初期使用，后期在整体系统构建完成后，再用解析式求导来加速，这时差分方法也可以来验证这里的变化。但是差分的作用不仅仅如此，更精彩的妙用是在<a href="https://xingxingzuo.github.io/" rel="external nofollow noopener" target="_blank">左星星老师</a><a href="https://arxiv.org/abs/2012.10133" rel="external nofollow noopener" target="_blank">CodeVIO</a>中的妙用，通过差分的方式来求解出CVAE的Jacobian。这篇论文也被ICRA2021提名为Robot Vsion方向的最佳论文，十分推荐大家去读读。说到深度学习，那李群和李代数在深度学习中又是怎么样呢？这里我就推荐CMU Chen wang老师的<a href="https://github.com/pypose/pypose" rel="external nofollow noopener" target="_blank">PyPose</a><d-cite key="wang2023pypose"></d-cite>。本期阅读过1500，点赞过200，我就尽力邀请王老师讲解下PyPose及其内部设计。</p> <h1 id="总结">总结。</h1> <p>本篇Blog我们回顾了李群的定义和数值差分求导的实现方式，希望能更好地帮助到SLAM研究者们能更快更好的构建自己的SLAM系统，最起码不会被Jacobian求解给难住。如果觉得我哪里写错或者不够清楚，欢迎email或评论区说出你的想法。</p> <div>声明：本文仅可<strong>被泡泡机器人SLAM</strong>与<strong>SJTU感知与导航研究所</strong>微信公众号转载，未经作者同意擅自转载将被作者依法追究其法律责任。 </div> </d-article> <d-appendix> <d-footnote-list></d-footnote-list> <d-citation-list></d-citation-list> </d-appendix> <d-bibliography src="/assets/bibliography/LieTheory.bib"></d-bibliography> </div> <footer class="fixed-bottom" role="contentinfo"> <div class="container mt-0"> © Copyright 2024 Qi. Wu. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/george-gca/multi-language-al-folio" rel="external nofollow noopener" target="_blank">multi-language-al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. Photos from <a href="https://unsplash.com" target="_blank" rel="external nofollow noopener">Unsplash</a>. </div> </footer> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script type="text/javascript">function progressBarSetup(){"max"in document.createElement("progress")?(initializeProgressElement(),$(document).on("scroll",function(){progressBar.attr({value:getCurrentScrollPosition()})}),$(window).on("resize",initializeProgressElement)):(resizeProgressBar(),$(document).on("scroll",resizeProgressBar),$(window).on("resize",resizeProgressBar))}function getCurrentScrollPosition(){return $(window).scrollTop()}function initializeProgressElement(){let e=$("#navbar").outerHeight(!0);$("body").css({"padding-top":e}),$("progress-container").css({"padding-top":e}),progressBar.css({top:e}),progressBar.attr({max:getDistanceToScroll(),value:getCurrentScrollPosition()})}function getDistanceToScroll(){return $(document).height()-$(window).height()}function resizeProgressBar(){progressBar.css({width:getWidthPercentage()+"%"})}function getWidthPercentage(){return getCurrentScrollPosition()/getDistanceToScroll()*100}const progressBar=$("#progress");window.onload=function(){setTimeout(progressBarSetup,50)};</script> </body> </html>